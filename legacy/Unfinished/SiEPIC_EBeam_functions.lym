<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>SiEPIC EBeam PDK functions</description>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># Python script
# SiEPIC_EBeam_functions

"""
This file is part of the SiEPIC_EBeam_PDK
by Lukas Chrostowski (c) 2015

This Python file implements various functions for the SiEPIC_EBeam_PDK 


NOTE: after changing the code, the macro needs to be rerun to install the new
implementation. The macro is also set to "auto run" these definitions and functions 
when KLayout is run.

Version history:

Lukas Chrostowski           2015/11/13
 - SiEPIC-EBeam-PDK Layer table 
 - Clear errors function
 - delete_extra_top_cells
 - function to delete extra cells
    def delete_extra_top_cells():
 - find all the automated measurement labels

Lukas Chrostowski           2015/11/15
 - fix for Python 3.4: print("xxx")
 - moved some functions from SiEPIC_EBeam_Verification, so they are accessible elsewhere.

Lukas Chrostowski           2015/11/16
 - fixes for component pin_type = Optical IO / FbrTgt being incorrectly handled; added Optical_pin.pin_type

Lukas Chrostowski           2015/11/17
 - debugging &amp; fixing Verification problems
   - Optical_*.n replaced with .idx, and starting from 0. -1 for undefined/disconnected.
   - added functions for listing:
     print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets)
     print_Optical_components(optical_components)
     print_Optical_waveguides(optical_waveguides)
     print_Optical_pins(optical_pins)
     print_Optical_nets(optical_nets)
 - improvements to Spice output, engineering format
 - extensive testing of verification, including large test layout
 - several floating point issues

Lukas Chrostowski           2015/11/18
 - removed need for numpy.array
  
Lukas Chrostowski           2015/11/19
 - finding the laser and detectors in the layout
 - generating a Spice netlist including Optical Network Analyzer; ready for Lumerical INTERCONNECT
 - Added Python 2 &amp; 3 compatibility for iter.next() vs. next(iter)

Lukas Chrostowski           2015/11/21
 - bug fix in points_mult, that argument in the function was being modified. needed to copy it.
 
Lukas Chrostowski           2015/12/9
 - .index() is a list method; replaced Optical_*.idx with .idx
 
 - Working towards merging ROUND_PATH and Waveguide_Route, into Waveguide_Route.  
   Provide option for netlist generation (simple, advanced).
   need to identify the Inst for waveguide, in find_all_waveguides, and save in optical_waveguides

Lukas Chrostowski           2016/04/19
 - Support for TM polarization in Netlist and laser

Lukas Chrostowski           2016/05/20
 - flag_waveguide_error, flag_component_error: verification flags on the layout are removed

Lukas Chrostowski           2016/11/06
 - adding capability to Ignore optical IOs in simulations: added as an option in the Laser.

Lukas Chrostowski           2017/02/12
 - adding electrical pin capability.  
   For now, donâ€™t consider the electrical wiring connectivity nor electrical pads.
   Assume that each electrical pin is connected to the outside (subckt)

"""

SiEPIC_Version = '0.1.6'

import pya
import math
import string

try:
  import numpy
except ImportError:
  #import numpy
  print("no numpy")
  MODULE_NUMPY = False

dbu = 0.001

# SiEPIC-EBeam-PDK Layers:
LayerSi = pya.LayerInfo(1, 0)
LayerSiSP = pya.LayerInfo(31, 0)
LayerText = pya.LayerInfo(10, 0)
LayerPinRec = pya.LayerInfo(69, 0)
LayerDevRec = pya.LayerInfo(68, 0)
LayerFbrTgt = pya.LayerInfo(81, 0)
LayerError = pya.LayerInfo(999,0)
LayerINTERCONNECT = pya.LayerInfo(733,0)


# define the types of waveguides we have, as defined in Path_to_Waveguide
#Waveguide_Types = "ROUND_PATH Waveguide_Route Waveguide_Route_simple"
#Waveguide_Types = ["ROUND_PATH", "Waveguide_Route", "Waveguide_Route_simple"]
Waveguide_Types = ["ROUND_PATH", "Waveguide_Route"]

# Netlist extraction will merge straight+bend sections into waveguide (1), 
# or extract each bend, straight section, etc. (0)
WAVEGUIDE_extract_simple = 1



# Determine whether we have Python 2 or Python 3
import sys
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3    

if PY3:
    # Python 3 code
    pass
else:
    # Python 2 code
    pass

try:
  advance_iterator = next
except NameError:
  def advance_iterator(it):
    return it.next()




# definition of classes for Verification, Waveguide making, Waveguide Healing
# one for each instance of the components
class Optical_component:
    def __init__(self, idx, component, instance, x, y, flip, rotate, library, params):
        self.idx = idx             # component index, should be unique, 0, 1, 2, ...
        self.component = component # which component (name) this pin belongs to
        self.instance = instance   # which component (instance) this pin belongs to
        self.x = x                 # instance location
        self.y = y                 # instance location
        self.flip = flip           # instance flip, True / False
        self.rotate = rotate       # instance rotation, 0, 90, 180, 270
        self.library = library     # compact model library
        self.nets = []             # nets connected to component
        self.npins = 0             # number of pins
        self.pins = []             # an array of all the optical pins
        self.nepins = 0            # number of epins
        self.epins = []            # an array of all the electrical pins
        self.params = params       # Spice parameters

def print_Optical_components(optical_components):
  print("Optical_components:")
  for o in optical_components:
    print("#%s: %s / %s, (%s, %s), nets %s, npins %s, pins %s, nepins %s, epins %s" %\
        (o.idx, o.component, o.instance, o.x, o.y, o.nets, o.npins, o.pins, o.nepins, o.epins) )
        
# definition for the optical waveguide class
class Optical_waveguide:
    def __init__(self, idx, points, radius, length, wg_type, num_points, wg_width, bend_pts):
        self.idx = idx            # waveguide index, should be unique, 0, 1, 2, ...
        self.points = points      # array of vertices, in database units
        self.radius = radius      # radius, in microns
        self.length = length      # length, in microns
        self.wg_type = wg_type    # wg_type: 0: path, 1: ROUND_PATH
        self.num_points = num_points # number of vertices in the path
        self.wg_width = wg_width  # waveguide width
        self.bend_pts = bend_pts  # number of points in a bend, per circle
        self.net1 = -1            # nets; one at each end of the waveguide
        self.net2 = -1            # nets; one at each end of the waveguide
        self.inst = 0             # class Instance for the waveguide cell instance
        self.component = "ebeam_wg_integral_1550"  # comprehensive waveguide model (regular and MC simulations)
#        self.component = "ebeam_wg_strip_1550"  # waveguide model name
        self.library = "Design kits/ebeam_v1.2" # compact model library
#        if 'SIMULATION' in globals():
#          if SIMULATION == 2:
#            self.component = "ebeam_wg_integral_1550"  # Monte Carlo waveguide model name

def print_Optical_waveguides(optical_waveguides):
  print("Optical_waveguides:")
  for o in optical_waveguides:
    print("#%s: length %s, type %s, net1: %s, net2: %s, points: %s" %\
        (o.idx, o.length, o.wg_type, o.net1, o.net2, o.points) )

class Optical_pin:
    def __init__(self, idx, points, component_idx, x, y, pin_type, pin_name):
        self.idx = idx                  # pin number, index, should be unique, 0, 1, 2, ...
        self.points = points            # array of vertices, in database units
        self.component_idx = component_idx  # which component index this pin belongs to
        self.net = -1                    # which net this pin is connected to
        self.x = x                      # x coordinate, in database units
        self.y = y                      # y coordinate, in database units
        self.pin_type = pin_type        # pin type: 0 = waveguide, 1 = component, 2 = opticalIO
        self.pin_name = pin_name        # label read from the cell layout (PinRec text)

def print_Optical_pins(optical_pins):
  print("Optical_pins:")
  for o in optical_pins:
    if o.pin_type == 1:
      points = o.points
    else:
      points = "..."
    print("#%s: component_idx %s, pin_name %s, pin_type %s, net: %s, (%s, %s), points: %s" %\
        (o.idx, o.component_idx, o.pin_name, o.pin_type, o.net, o.x, o.y, points) )

class Optical_net:
    def __init__(self, idx, pin1_type, pin1_n, pin2_type, pin2_n):
        self.idx = idx                  # net number, index, should be unique, 0, 1, 2, ...
        # an optical net can only connect to two pins. 
        # the pin variables point to either Optical_waveguide or Optical_component classes
        self.pin1_type = pin1_type      # pin type: 0 = waveguide, 1 = component, 2 = opticalIO
        self.pin1_n = pin1_n            # pin n: component or waveguide index
        self.pin2_type = pin2_type
        self.pin2_n = pin2_n

def print_Optical_nets(optical_nets):
  print("Optical_nets:")
  for o in optical_nets:
    if o.pin1_type != 0:
      name1 = optical_components[optical_pins[o.pin1_n].component_idx].component
#      name1 = optical_components[o.pin1_n].component
    else:
      name1 = 'waveguide'
    if o.pin2_type != 0:
      name2 = optical_components[optical_pins[o.pin2_n].component_idx].component
#      name2 = optical_components[o.pin2_n].component
    else:
      name2 = 'waveguide'
    print("#%s: pin1: %s (%s) pin_type1: %s; pin2: %s (%s) pin_type2: %s" %\
        (o.idx, o.pin1_n, name1, o.pin1_type, o.pin2_n, name2, o.pin2_type) )

def print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets):
  print_Optical_components(optical_components)
  print_Optical_waveguides(optical_waveguides)
  print_Optical_pins(optical_pins)
  print_Optical_nets(optical_nets)

class Layout_error:
    # for keeeping track of layout errors
    n = 0
    def __init__(self, text, x, y):
        Layout_error.n += 1
        self.text = text              # error text
        self.x = x                    # error location
        self.y = y                    # error location

def reset_Optical_classes():
  Layout_error.n = 0

# multiply an array of points by a constant
def points_mult(dpoints1, mult):
  # create a new empty list.  Otherwise, this function would modify the original list
  # http://stackoverflow.com/questions/240178/python-list-of-lists-changes-reflected-across-sublists-unexpectedly
  newlist = [[0]*2 for n in range(len(dpoints1))] 
  if MODULE_NUMPY:
    return numpy.array(dpoints1)*mult
  else:
    for i in range(0,2):
      for j in range(0,len(dpoints1)):
        newlist[j][i] = dpoints1[j][i]*mult
    return newlist

# calculate the mean in (x,y) for an array of points
def xy_mean_mult(dpoints,dbu):
  if MODULE_NUMPY:
    x = numpy.array(dpoints)[:,0].mean()*dbu
    y = numpy.array(dpoints)[:,1].mean()*dbu
  else:
    x=0
    y=0
    for i in range(0,len(dpoints)):
      x += dpoints[i][0]
      y += dpoints[i][1]
    x = x / len(dpoints) * dbu
    y = y / len(dpoints) * dbu
  return x,y


# Clear the error markers generated by SiEPIC_EBeam_Verification
def clear_ErrorLayer(topcell, LayerErrorN):
  iter1 = topcell.begin_shapes_rec(LayerErrorN)
  
  i=0
  while not(iter1.at_end()):
    if iter1.shape().is_path() | iter1.shape().is_box():
      i+=1
      iter1.shape().delete()
    iter1.next()  
  print("*** Deleted %s errors." % i)



import string
def find_automated_measurement_labels(topcell, LayerTextN):
  # example usage:
  # topcell = pya.Application.instance().main_window().current_view().active_cellview().cell
  # LayerText = pya.LayerInfo(10, 0)
  # LayerTextN = topcell.layout().layer(LayerText)
  # find_automated_measurement_labels(topcell, LayerTextN)
  t = ''
  dbu = topcell.layout().dbu
  iter = topcell.begin_shapes_rec(LayerTextN)
  i=0
  while not(iter.at_end()):
    if iter.shape().is_text():
      text = iter.shape().text
      if text.string.find("opt_in") &gt; -1:
        i+=1
        text2 = iter.shape().text.transformed(iter.itrans())
        t += "label: %s, location: (%s, %s) &lt;br&gt;" %(text.string, text2.x*dbu, text2.y*dbu )
    iter.next()
  t += "&lt;br&gt;*** Number of automated measurement labels: %s.&lt;br&gt;" % i
  return t

# sorting the pins uses the Pin_info class:
class Pin_info:
  def __init__(self, pin_text, pin_x, pin_y):
    self.pin_text = pin_text
    self.pin_x = pin_x
    self.pin_y = pin_y
  
def find_all_components(cell, LayerDevRecN, LayerPinRecN, LayerFbrTgtN):
  # function to traverse the entire layout hierarchy and find all the components
  # returns list of components, location, orientation
  # use the DevRec shapes.  One DevRec shape per component.
  
  # Find all the DevRec shapes; identify the component it belongs; record the instance info as an Optical_component 
  # for each component instance, also find the Pins and Fibre ports.
  
  # Use the pin names on layer PinRec to sort the pins in alphabetical order
  #   Requires that a text label be in PinRec layer, co-linear inside the PinRec path.

  # Find all the DevRec shapes
  iter1 = cell.begin_shapes_rec(LayerDevRecN)
  i=0
  while not(iter1.at_end()):
    i+=1
    subcell = iter1.cell()                     # cell (component) to which this shape belongs
    component = subcell.basic_name()   # name library component
    instance = subcell.name      
    subcell.name                # name of the cell; for PCells, different from basic_name
    found_component = False
    # DevRec must be either a Box or a Polygon:
    if iter1.shape().is_box():
      box= iter1.shape().box.transformed(iter1.itrans())
      print("%s: DevRec in cell {%s}, box -- %s; %s"   % (i, subcell.basic_name(), box.p1, box.p2) )
      found_component = True
    if iter1.shape().is_polygon():
      polygon = iter1.shape().polygon.transformed(iter1.itrans())
      print("%s: DevRec in cell {%s}, polygon -- %s"   % (i, subcell.basic_name(), polygon))
      found_component = True

    # A component was found. record the instance info as an Optical_component 
    if found_component:
      # Find text label for DevRec, to get Library name
      library = None
      iter2 = subcell.begin_shapes_rec(LayerDevRecN)
      spice_params = ""
      while not(iter2.at_end()):
        if iter2.shape().is_text():
          text = iter2.shape().text
          print("%s: DevRec label: %s" % (i, text))
          if text.string.find("Lumerical_INTERCONNECT_library=") &gt; -1:
            library = text.string[len("Lumerical_INTERCONNECT_library="):]
          if text.string.find("Lumerical_INTERCONNECT_component=") &gt; -1:
            component = text.string[len("Lumerical_INTERCONNECT_component="):]
          if text.string.find("Spice_param:") &gt; -1:
            spice_params = text.string[len("Spice_param:"):]
        iter2.next()
      if library == None:
        print("Missing library information for component: %s" % component )
      x = iter1.itrans().disp.x*dbu
      y = iter1.itrans().disp.y*dbu
      flip = iter1.trans().is_mirror()
      rotate = (int(iter1.trans().rot())*90) % 360
      component_idx = len(optical_components)
      optical_components.append ( Optical_component (component_idx, \
                  component, instance, x, y, flip, rotate, library, spice_params) )
      
      # Find the PinRec and record info as Optical_pin
      
      # Use the pin names on layer PinRec to sort the pins in alphabetical order
      # read; sort; save data.
      iter2 = subcell.begin_shapes_rec(LayerPinRecN)
      pin_info1 = []  # array for Pin_info
      path_points=[]
      path_shape=[]   # for optical pins
      box_shape=[]    # for electrical pins
      while not(iter2.at_end()):
        # Find text label for PinRec, to get the port numbers
        if iter2.shape().is_text():
          texto= iter2.shape().text.transformed(iter2.itrans())
          texto= texto.transformed(iter1.itrans())
          x = texto.x
          y = texto.y
#          print( "PinRec label: %s at (%s, %s)" % (iter2.shape().text, x, y) )
          pin_info1.append(Pin_info(iter2.shape().text.string, x, y))
        if iter2.shape().is_path():
          # assume this is an optical pin
          path= iter2.shape().path.transformed(iter2.itrans()).transformed(iter1.itrans())
          points = path_to_points(path)  
#          print( "%s: PinRec in cell {%s}, path -- %s"   % (i, iter2.cell().name, path) )
          path_points.append(points)
          path_shape.append(iter2.shape())
        if iter2.shape().is_box():
          # assume this is an electrical pin
          box = iter2.shape().box.transformed(iter2.itrans()).transformed(iter1.itrans())
          box_shape.append(box)
#          print( "%s: PinRec in cell {%s}, box -- %s"   % (i, iter2.cell().name, box) )
        iter2.next()
      # Sort pin text labels
      pin_info2 = sorted(pin_info1, key=lambda  pin_info0: pin_info0.pin_text)
      
      # find pin labels that are inside the DevRec shape:
      for p1 in range(0,len(pin_info2)):
        for p2 in range(0,len(path_shape)):  # (optical)
          # Check if the pin text label is somewhere along the pin path
#          check_text_in_pin = check_point_in_segment( \
#            pya.Point( *path_points[p2][0] ), \
#            pya.Point( *path_points[p2][1] ), \
#            pya.Point( pin_info2[p1].pin_x, pin_info2[p1].pin_y ) )
          # Check if the pin text label is exactly in the middle of pin path
          points = path_points[p2]  
          x = (points[0][0]+points[1][0])/2   # midpoint of pin path
          y = (points[0][1]+points[1][1])/2
          check_text_in_pin = ( x == pin_info2[p1].pin_x ) &amp; \
                              ( y == pin_info2[p1].pin_y )
          if check_text_in_pin:
            pin_idx = len(optical_pins)
            optical_pins.append (Optical_pin (pin_idx, points, component_idx, x, y, 1, pin_info2[p1].pin_text) )
            optical_components[component_idx].npins += 1
            optical_components[component_idx].pins.append( pin_idx )
            print("%s: PinRec (text=%s) in cell {%s}, component #%s, path -- %s"   \
              % (i, pin_info2[p1].pin_text, iter2.cell().name, component_idx, path_to_points(path_shape[p2].path)) )
        for p2 in range(0,len(box_shape)):
          # Check if the pin text label is inside the DevRec pin box (electrical)
          print('epin x: %s, %s, %s' % (pin_info2[p1].pin_x,box_shape[p2].left,box_shape[p2].right))
          print('epin y: %s, %s, %s' % (pin_info2[p1].pin_y,box_shape[p2].bottom,box_shape[p2].top))
          if (pin_info2[p1].pin_x &gt; box_shape[p2].left) &amp; \
             (pin_info2[p1].pin_x &lt; box_shape[p2].right) &amp; \
             (pin_info2[p1].pin_y &gt; box_shape[p2].bottom) &amp; \
             (pin_info2[p1].pin_y &lt; box_shape[p2].top):
            optical_components[component_idx].nepins += 1
            optical_components[component_idx].epins.append(pin_info2[p1].pin_text  )
            print("%s: PinRec (text=%s) in cell {%s}, component #%s, box -- %s"   \
              % (i, pin_info2[p1].pin_text, iter2.cell().name, component_idx, box_shape[p2]) )
          

      # reserve space for netlist for this component, based on the number of pins.
      optical_components[component_idx].nets = [-1] * (optical_components[component_idx].npins)

      # Find the FbrTgt, and record info as Optical_pin
      iter2 = subcell.begin_shapes_rec(LayerFbrTgtN)
      while not(iter2.at_end()):
        if iter2.shape().is_polygon():
          polygon = iter2.shape().polygon.transformed(iter2.itrans())
          polygon = polygon.transformed(iter1.itrans())
          # What do we want to do with the Fibre ports?
          # create a net (with only 1 member = the optical IO)
          net_idx = len(optical_nets)
          optical_nets.append ( Optical_net (net_idx, 2, component_idx, -1, -1) ) #ok
          # create a pin, optical IO
          bb = polygon.bbox()
          x, y = xy_mean_mult([[bb.p1.x, bb.p1.y], [bb.p2.x, bb.p2.y]],1)
#          x, y = numpy.mean([bb.p1.x, bb.p2.x]), numpy.mean([bb.p1.y, bb.p2.y])
          pin_idx = len(optical_pins)
          optical_pins.append (Optical_pin (pin_idx, polygon_to_points(polygon), component_idx, x, y, 2, "pin0") )
          # register the net with the pin and component
          optical_pins[pin_idx].net = net_idx
          optical_components[component_idx].nets.insert(0, net_idx )
          # register the pin with the component
          optical_components[component_idx].npins += 1
          optical_components[component_idx].pins.insert(0, pin_idx ) 
          print("%s: FbrTgt in cell {%s}, at (%s, %s), net %s, pins %s, component # %s, component nets %s" \
              % (i, iter2.cell().name, x, y, net_idx, optical_components[component_idx].pins, \
              component_idx, optical_components[component_idx].nets ) )
        iter2.next()


    # end if found_component   
     
    iter1.next()
 
  # end while iter1 
# end def find_all_components


def distance_xy ( p1, p2 ):
  # calculate the distance between two points
  # input in dbu
  # output in microns
  distance = math.sqrt ( (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 ) * dbu  
  return distance


import math
def angle_segment(seg):
  pt1, pt2 = seg
  x2, y2 = pt2
  x1, y1 = pt1
  rads1 = math.atan2(y2-y1,x2-x1)
  return (rads1)/math.pi*180

def angle_vectors(pt1, pt2):
  x1, y1 = pt1
  x2, y2 = pt2
  rads1 = math.atan2(y1,x1)
  rads2 = math.atan2(y2,x2)
  return (rads2-rads1)/math.pi*180

def angle_segments(segA, segB):
  ptA1, ptA2 = segA
  ptB1, ptB2 = segB
  return angle_vectors([ptA2[0]-ptA1[0], ptA2[1]-ptA1[1]], [ptB2[0]-ptB1[0], ptB2[1]-ptB1[1]])

def av_angle_segments(segA, segB):
  ptA1, ptA2 = segA
  ptB1, ptB2 = segB
  angleA = math.atan2(ptA2[1]-ptA1[1], ptA2[0]-ptA1[0])
  angleB = math.atan2(ptB2[1]-ptB1[1], ptB2[0]-ptB1[0])
  return (angleA+angleB)/2/math.pi*180
#  return angle_vectors([ptA2[0]-ptA1[0], ptA2[1]-ptA1[1]], [ptB2[0]-ptB1[0], ptB2[1]-ptB1[1]])


def points_per_circle(radius):
  # Calculate the recommended number of points in a circle, based on 
  # http://stackoverflow.com/questions/11774038/how-to-render-a-circle-with-as-few-vertices-as-possible
  # radius in microns
#  import numpy as n
  error=0.5e-3 # 0.5 nm
  if radius &gt; 0.1:
    th = math.acos(2 * (1 - error / radius)**2 - 1)
    num_vertices = math.ceil(2*math.pi/th)
    return int(num_vertices)
  else:
    return 100

def path_to_points(path):
  # function to convert a KLayout Path object to an array of points
  # iterate through all the points in the path, and construct array
  p_iter = path.each_point()
  points = []
  try:
    while True:
       p = advance_iterator(p_iter)
       # assume input Integer type; need to round due to floating point issues.
       points.append( [int(round(p.x)), int(round(p.y))] )
  except StopIteration:
    pass    
  return points


def path_to_Dpoints(path):
  # function to convert a KLayout Path object to an array of points
  # iterate through all the points in the path, and 
  p_iter = path.each_point()
  points = []
  try:
    while True:
       p = advance_iterator(p_iter)
       points.append( [(p.x), (p.y)] )
  except StopIteration:
    pass    
  return points

  
def points_to_Dpath(points, w):
  a1 = []
  for p in points:
    a1.append (pya.DPoint(p[0], p[1]))
  wg_path1 = pya.DPath(a1, w)
  return wg_path1


def points_to_path(points, w):
  a1 = []
  for p in points:
    a1.append (pya.Point(p[0], p[1]))
  wg_path = pya.Path(a1, w)
  return wg_path
  
  
def polygon_to_points(polygon):
  # for some reason, you can assign points to a polygon, but not read them!
  # http://www.klayout.de/doc/code/class_SimplePolygon.html
  # This function reads the points one by one and returns an array of points
  npts = polygon.to_simple_polygon().points
  ps = polygon.to_simple_polygon()
  points = []
  for k in range(0,npts):
    pt = ps.point(k)
    points.append ( [pt.x, pt.y] )
  return points
  

def check_point_in_segment(a, b, c):
    """ How can you determine a point is between two other points on a line segment?
    http://stackoverflow.com/questions/328107/how-can-you-determine-a-point-is-between-two-other-points-on-a-line-segment
    by Cyrille Ka.  Check if c is between a and b? """
    # print( "%s, %s; %s, %s; %s, %s" % (a.x, a.y, b.x, b.y, c.x, c.y) )
    crossproduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y)
    if abs(crossproduct) != 0 : return False 
    dotproduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y)*(b.y - a.y)
    if dotproduct &lt; 0 : return False
    squaredlengthba = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y)
    if dotproduct &gt; squaredlengthba: return False
    return True


def PCell_get_parameter_list ( cell_name, library_name ):
  # function to list all the parameters &amp; defaults for a PCell
  # example usage:
  # PCell_get_parameter_list("CIRCLE", "Basic")
  print("* def PCell_get_parameter_list ( %s, %s): ") % ( cell_name, library_name )
  lib = pya.Library.library_by_name(library_name)
  if lib == None:
    raise Exception("Unknown lib '%s'" % library_name)
  pcell_decl = lib.layout().pcell_declaration(cell_name);
  if pcell_decl == None:
     raise Exception("Unknown PCell '%s'" % cell_name)
  type2s = ['TypeBoolean', 'TypeDouble', 'TypeInt', 'TypeLayer', 'TypeList', 'TypeNone', 'TypeShape', 'TypeString']
  for p in pcell_decl.get_parameters():
    if ~p.readonly:
      print( "Name: %s, %s, unit: %s, default: %s, description: %s%s" % \
        (p.name, type2s[p.type], p.unit, p.default, p.description, ", hidden" if p.hidden else ".") )


def PCell_get_parameters ( pcell ):
  # function to list the values for all parameters for an intantiated PCell
  # example usage:
  # ly = pya.Application.instance().main_window().current_view().active_cellview().layout() 
  # pcell = ly.create_cell("CIRCLE", "Basic", { "actual_radius": 10, "layer": pya.LayerInfo(1, 0) } )
  # PCell_get_parameters( pcell )
  print("* def PCell_get_parameters ( %s ):") % pcell 
  print( pcell.pcell_parameters() )
  params = pcell.pcell_parameters_by_name()
  for param in params.keys():
    print("Parameter: %s, Value: %s") % (param, params[param])
  return params
  
def find_PCell_pins(subcell):
  # find the location of the pins in the cell.
  # example usage:
  # ly = pya.Application.instance().main_window().current_view().active_cellview().layout() 
  # pcell = ly.create_cell("Waveguide_Bend", "SiEPIC", { } )
  # find_PCell_pins( pcell )

  LayerPinRecN = subcell.layout().layer(LayerPinRec)
  iter2 = subcell.begin_shapes_rec(LayerPinRecN)
  pins = {} # dictionary for pin information
  while not(iter2.at_end()):
    # Find text label for PinRec, to get the port numbers
    if iter2.shape().is_text():
      texto= iter2.shape().text.transformed(iter2.itrans())
      x = texto.x
      y = texto.y
      text = iter2.shape().text
#      print( "PinRec label: %s at (%s, %s)" % (text, x, y) )
      pins[ str(text.string) + "_x" ] = x
      pins[ str(text.string) + "_y" ] = y
    iter2.next()

  return pins
  


def get_LumericalINTERCONNECT_analyzers(topcell, optical_pins):
  """
  Find - LumericalINTERCONNECT_Laser
       - LumericalINTERCONNECT_Detector
  get their parameters
  determine which OpticalIO they are connected to, and find their nets
  Assume that the detectors and laser are on the topcell (not subcells); don't perform transformations.
  
  returns: parameters, nets in order
  
  usage:
  laser_net, detector_nets, wavelength_start, wavelength_stop, wavelength_points, ignoreOpticalIOs = get_LumericalINTERCONNECT_analyzers(topcell, optical_pins)
  """
  
  layout = topcell.layout()
  LayerINTERCONNECTN = layout.layer(LayerINTERCONNECT)

  # data structure used to find the detectors and which optical nets they are connected to.
  class Detector_info:
    def __init__(self, detector_net, detector_number):
      self.detector_net = detector_net
      self.detector_number = detector_number
  detectors_info = []  
  
  # default is the 1st polarization
  orthogonal_identifier = 1
      
  # Find the laser and detectors in the layout.
  iter1 = topcell.begin_shapes_rec(LayerINTERCONNECTN)
  n_laser = 0
  laser_net = -1
  wavelength_start, wavelength_stop, wavelength_points, orthogonal_identifier, ignoreOpticalIOs = 0,0,0,0,0
  n_detector = 0
  while not(iter1.at_end()):
    subcell = iter1.cell()             # cell (component) to which this shape belongs
    if iter1.shape().is_box():
      box = iter1.shape().box.transformed(iter1.itrans())
      if iter1.cell().basic_name() == "LumericalINTERCONNECT_Detector":
        n_detector += 1
        detector_number = subcell.pcell_parameters_by_name()["number"]
        print("%s: Detector {%s} %s, box -- %s; %s"   % (n_detector, subcell.basic_name(), detector_number, box.p1, box.p2) )
        npins_inside_detector = 0
        for pin in optical_pins:
          if pin.pin_type == 2:  # Optical IO
            # Check if the OpticalIO x,y is inside the detector box
            pin_box = pya.Box(pin.x, pin.y, pin.x, pin.y)
            if pin_box.inside(box):
              # found optical
              print("Optical IO pin connected to detector.  Pin #%s: component_idx %s, pin_type %s, net: %s, (%s, %s)" %\
                  (pin.idx, pin.component_idx, pin.pin_type, pin.net, pin.x, pin.y) )
              npins_inside_detector += 1
              detectors_info.append( Detector_info(pin.net, detector_number) ) 
        if npins_inside_detector &gt; 1:
          print(" *** Error - more than 1 optical IO connected to the detector. ")
      if iter1.cell().basic_name() == "LumericalINTERCONNECT_Laser":
        n_laser += 1
        print("%s: Laser {%s}, box -- %s; %s"   % (n_laser, subcell.basic_name(), box.p1, box.p2) )
        wavelength_start = subcell.pcell_parameters_by_name()["wavelength_start"]
        wavelength_stop = subcell.pcell_parameters_by_name()["wavelength_stop"]
        wavelength_points = subcell.pcell_parameters_by_name()["npoints"]
        orthogonal_identifier = subcell.pcell_parameters_by_name()["orthogonal_identifier"]
        ignoreOpticalIOs = subcell.pcell_parameters_by_name()["ignoreOpticalIOs"]
        npins_inside_laser = 0
        for pin in optical_pins:
          if pin.pin_type == 2:  # Optical IO
            # Check if the OpticalIO x,y is inside the laser box
            pin_box = pya.Box(pin.x, pin.y, pin.x, pin.y)
            if pin_box.inside(box):
              # found optical
              print("Optical IO pin connected to laser.  Pin #%s: component_idx %s, pin_type %s, net: %s, (%s, %s)" %\
                  (pin.idx, pin.component_idx, pin.pin_type, pin.net, pin.x, pin.y) )
              npins_inside_laser += 1
              laser_net = pin.net  
        if npins_inside_laser &gt; 1:
          print(" *** Error - more than 1 optical IO connected to the laser. ")
            
    iter1.next()
    
  # Sort the detectors:
  detectors_info2 = sorted(detectors_info, key=lambda  d: d.detector_number)
    
  # output:
  detector_nets = []
  for d in detectors_info2:
    detector_nets.append (d.detector_net)

  return laser_net, detector_nets, wavelength_start, wavelength_stop, wavelength_points, orthogonal_identifier, ignoreOpticalIOs
    
  
def find_all_waveguides(cell, layer):
  # function to traverse the entire layout hierarchy and find all the waveguides 
  # returns array listing all paths
  # Search for ROUND_PATH PCells and straight paths

  # return data containing:
  # - net id: unique identifier for the net
  # - vertices: points that make up the path

  dbu = cell.layout().dbu
  
  iter1 = cell.begin_shapes_rec(layer)
  i=0
  while not(iter1.at_end()):
    i+=1
    found_wg = False
    
    if iter1.shape().is_path():
      # This is a waveguide that is a path.  It should be only a straight line with no bends
      path_obj= iter1.shape()
      wg_path = path_obj.path
      num_points = path_obj.path.num_points()
      if num_points == 2:
        # insert a mid-point in the waveguide, so that it can later be split into two nets
        points = path_to_points(path_obj)
        a1 = []
        count =0
        for p in points:
          a1.append (pya.Point(p[0], p[1]))
          count += 1
          if count == 1:
            # add a point:
            a1.append( pya.Point( (points[0][0] + points[1][0])/2, (points[0][1] + points[1][1])/2 )  )
        wg_path = pya.Path(a1, path_obj.path.width)
      path = wg_path.transformed(iter1.itrans())   # get the path description        
      # Waveguide parameters
      length =  path.length()*dbu 
      radius = 0
      wg_type = 0
      bend_pts = 0
      wg_width = path.width*dbu
      print("Waveguide #%s: In cell {%s}, num_points: %s, length: %s, radius: %s, path: %s"  \
           % (i, iter1.cell().name, num_points, length, radius, path) )
      found_wg = True
      
    if iter1.shape().is_polygon():
      if iter1.cell().basic_name() == "ROUND_PATH" or \
        (iter1.cell().basic_name() == "Waveguide_Route" and WAVEGUIDE_extract_simple ):
        # This is a waveguide implemented using a PCell ROUND_PATH
        subcell = iter1.cell()
        if subcell.is_pcell_variant():    
          # Get the waveguide guiding shape path from the "ROUND_PATH" PCell 
          DPath = subcell.pcell_parameters_by_name()["path"]*(1/dbu)  # DPath object
          ipath = pya.Path.from_dpath(DPath)  # Construct an integer-coordinate path from a floating-point coordinate one

          # Find out the transformation that needs to be performed on the path relative to the top cell
          # and apply this on the waveguide guiding shape path
          trans = iter1.trans() # CplxTrans object of the instance 
          DCplxTrans = pya.DCplxTrans.from_itrans(trans) # need CplxTrans to DCplxTrans
          path = DPath.transformed(DCplxTrans)

          # Waveguide parameters
          print(subcell.pcell_parameters_by_name())
          radius = subcell.pcell_parameters_by_name()["radius"]  # in microns
          bend_pts = subcell.pcell_parameters_by_name()["npoints"] 
          wg_width = subcell.pcell_parameters_by_name()['path'].width  # in microns
          # calculate the length of the waveguide using the area / width
          iter2 = subcell.begin_shapes_rec(LayerSiN)
          if iter2.shape().is_polygon():
            area = iter2.shape().polygon.area()
            length = area / wg_width * dbu * dbu
          else:
            print("## ROUND_PATH waveguide, not polygon; bug in code? ##")
            length =  path.length()*dbu  # ignoring bends
          num_points = path.num_points()
          wg_type = 1
          print("Waveguide #%s: In cell {%s}, num_points: %s, length: %s, radius: %s, path: %s" \
              % (i, subcell.name, num_points, length, radius, path) )
          found_wg = True
        else:
          print("## ROUND_PATH cell, but not a PCell. Can't extract info. ##")
          v = pya.MessageBox.warning("Can't extract waveguide", "Verification warning: Can't extract waveguide.\nFound a %s waveguide, but it isn't a PCell. \nNote: This verification only works on original KLayout-created layouts (not merged)." % iter1.cell().basic_name(), pya.MessageBox.Ok)

    if found_wg:
      points = path_to_points(path)  
      print("path: %s, points: %s" % (path, points) )
      # save waveguide info into the Optical_waveguide
      optical_waveguides.append ( Optical_waveguide (len(optical_waveguides), points, radius, \
          length, wg_type, num_points, wg_width, bend_pts ) )

    iter1.next()
  print(" ")

def check_segments_same_direction( segment1, segment2 ):
  # check that they have the same direction
  is_slope_equal = False
  # check âˆ†x = 0 first to avoid division by 0
  dx1 = (segment1[0].x-segment1[1].x)
  dx2 = (segment2[0].x-segment2[1].x)
  if dx2 == 0 and dx1 == 0:
    is_slope_equal = True  # both vertical
  elif dx1 != 0 and dx2 != 0:
    # check slopes
    slope1 = (segment1[0].y-segment1[1].y) / (segment1[0].x-segment1[1].x)
    slope2 = (segment2[0].y-segment2[1].y) / (segment2[0].x-segment2[1].x)
    if slope1 == slope2:
      is_slope_equal = True  # both have the same slope
  return is_slope_equal
 

def check_segments_collinear_overlapping( segment1, segment2 ):
  """ 
  we want to identify ONLY the following situation:
        X  O  X  O
  where XX is a segment, and OO is another segment
  namely, collinear, but also XX overlapping OO
  example usage: 
    a = pya.Point(0,0)
    b = pya.Point(50,0)
    c = pya.Point(50,0)
    d = pya.Point(100,0)
    segment1 = [ a, b ]
    segment2 = [ c, d ]
    print(check_segments_collinear_overlapping( segment1, segment2 ))
  """  

  # check for one of the segment2 points being inside segment1
  check_between1 = check_point_in_segment( segment1[0], segment1[1], segment2[0] ) | \
                  check_point_in_segment( segment1[0], segment1[1], segment2[1] )
  # check for one of the segment1 points being inside segment2
  check_between2 = check_point_in_segment( segment2[0], segment2[1], segment1[0] ) | \
                  check_point_in_segment( segment2[0], segment2[1], segment1[1] )

  # check that they have the same direction
  is_slope_equal = check_segments_same_direction( segment1, segment2 )
#  print( "check_segments_collinear_overlapping: %s, %s, %s, %s: %s, %s, %s" % (segment1[0], segment1[1], segment2[0], segment2[1], check_between1, check_between2, is_slope_equal) )
  
  return (check_between1 or check_between2) and is_slope_equal


def identify_all_nets(optical_pins, optical_waveguides, optical_components):
  # function to identify all the nets from the layout
  # use the data in Optical_pin, Optical_waveguide to find overlaps
  # and save results in Optical_component

  # Make sure that there are exactly 2 pins for each net (not like in electronics!)

  # Loop through all the pins (p1)
  # - find other overlapping pins (p2)
  # - find overlapping waveguide ends
  for p1 in optical_pins:
    if p1.pin_type != 1:
      continue # only analyze pin_type = 1, component.
      
    segment1 = [ pya.Point(*p1.points[0]), pya.Point(*p1.points[1]) ] 

    # Compare to all other pins:
    for p2 in optical_pins[ p1.idx+1: len(optical_pins) ]:
      if p2.pin_type != 1:
        continue # only analyze pin_type = 1, component.
      #print("%s, %s, %s, %s" % (p1.n, p1.points, p2.n, p2.points) )
      segment2 = [ pya.Point(*p2.points[0]), pya.Point(*p2.points[1]) ] 
      # first check that the pins are pointing in the same direction and overlapping:
      check = check_segments_collinear_overlapping( segment1, segment2 )
      # then check that the pin centres are perfectly overlapping (to avoid phase errors in simulations, slight disconnections)
      x1 = (p1.points[0][0]+p1.points[1][0])/2   # midpoint of pin path
      y1 = (p1.points[0][1]+p1.points[1][1])/2
      x2 = (p2.points[0][0]+p2.points[1][0])/2   # midpoint of pin path
      y2 = (p2.points[0][1]+p2.points[1][1])/2
      #print("compare (%s, %s) - (%s, %s): %s %s, %s" % (x1, y1, x2, y2, (x1 == x2), (y1 == y2), check) )
      check2 = (x1 == x2) and (y1 == y2)
      if check and check2:  # found connected pins:
        # make a new optical net
        net_idx = len(optical_nets)
        # optical net connects two pins; keep track of pin index:
        optical_nets.append ( Optical_net (net_idx, 1, p1.idx, 1, p2.idx) )
        # assign this net number to the components
        # find which where p1 and p2 are in the component:
        p1_comp = optical_components[p1.component_idx]
        p2_comp = optical_components[p2.component_idx]
        p1_comp.nets[p1_comp.pins.index(p1.idx)] = net_idx
        p2_comp.nets[p2_comp.pins.index(p2.idx)] = net_idx
        # assign this net number to the pins
        p1.net = net_idx
        p2.net = net_idx
        print( "connected: pin-pin, net: %s, component,pin #: [%s, %s], [%s, %s]" % (net_idx, p1.component_idx, p1.pin_name, p2.component_idx, p2.pin_name) )
        
    # Compare to all waveguides:
    for w1 in optical_waveguides:
      # examine the beginning of the waveguide:
      segment2 = [ pya.Point(*w1.points[0]), pya.Point(*w1.points[1]) ] 
      # first check that the pin is pointing in the same direction and overlapping as the waveguide segment:
      check1 = check_segments_collinear_overlapping( segment1, segment2 )
      # then check that the waveguide endpoint is perfectly at the pin centre
      x1 = (p1.points[0][0]+p1.points[1][0])/2   # midpoint of pin path
      y1 = (p1.points[0][1]+p1.points[1][1])/2
      x2 = w1.points[0][0]   # endpoint of waveguide
      y2 = w1.points[0][1]
      check1b = (x1 == x2) and (y1 == y2)
      if check1 and check1b:  # found connected pins:
        # make a new optical net
        net_idx = len(optical_nets)
        optical_nets.append ( Optical_net (net_idx, 1, p1.component_idx, 0, w1.idx) )
        # assign this net number to the components
        p1_comp = optical_components[p1.component_idx]
        p1_comp.nets[p1_comp.pins.index(p1.idx)] = net_idx
###        optical_components[p1.component_idx].nets.append (net_idx)
        if optical_waveguides[w1.idx].net1 != -1:
          # problem. Net is already assigned.
          text = "  *** Connectivity error.  Net is already assigned (pin to waveguide). Overwriting."
          flag_waveguide_error( [w1.points[0], w1.points[1]], text, optical_waveguides[w1.idx], topcell)
        optical_waveguides[w1.idx].net1 = net_idx
        # assign this net number to the pin
        p1.net = net_idx
        print( "connected: pin-waveguide, net #: %s, component #: %s, pin #: %s, waveguide #: %s" \
              % (net_idx, p1.component_idx, p1.idx, w1.idx ) )
        
      # examine the end of the waveguide:
      np = len(w1.points)
      segment2 = [ pya.Point(*w1.points[np-2]), pya.Point(*w1.points[np-1]) ] 
      # first check that the pin is pointing in the same direction and overlapping as the waveguide segment:
      check2 = check_segments_collinear_overlapping( segment1, segment2 )
      # then check that the waveguide endpoint is perfectly at the pin centre
      x1 = (p1.points[0][0]+p1.points[1][0])/2   # midpoint of pin path
      y1 = (p1.points[0][1]+p1.points[1][1])/2
      x2 = w1.points[np-1][0]   # endpoint of waveguide
      y2 = w1.points[np-1][1]
      check2b = (x1 == x2) and (y1 == y2)
      if check2 and check2b:  # found connected pins:
        # make a new optical net
        net_idx = len(optical_nets)
        optical_nets.append ( Optical_net (net_idx, 1, p1.component_idx, 0, w1.idx) )
        # assign this net number to the components
        p1_comp = optical_components[p1.component_idx]
        p1_comp.nets[p1_comp.pins.index(p1.idx)] = net_idx
###        optical_components[p1.component_idx].nets.append (net_idx)
        if optical_waveguides[w1.idx].net2 != -1:
          # problem. Net is already assigned.
          text = "  *** Connectivity error.  Net is already assigned (pin to waveguide). Overwriting."
          flag_waveguide_error([w1.points[len(w1.points)-1], w1.points[len(w1.points)-2]], \
                  text, optical_waveguides[w1.idx], topcell)
        optical_waveguides[w1.idx].net2 = net_idx
        # assign this net number to the pin
        p1.net = net_idx
        print( "connected: pin-waveguide, net #: %s, component #: %s, pin #: %s, waveguide #: %s" \
              % (net_idx, p1.component_idx, p1.idx, w1.idx ) )
     

  # Check for waveguide to waveguide connections, make net
  # Loop through all waveguides, and compare to all other waveguides
  for w1 in optical_waveguides:
    # the beginning of waveguide 1:
    w1_segment1 = [ pya.Point(*w1.points[0]), pya.Point(*w1.points[1]) ] 
    # the end of waveguide 2:
    np = len(w1.points)
    w1_segment2 = [ pya.Point(*w1.points[np-2]), pya.Point(*w1.points[np-1]) ] 
    for w2 in optical_waveguides[ w1.idx+1: len(optical_waveguides) ]:
      # the beginning of waveguide 2:
      w2_segment1 = [ pya.Point(*w2.points[0]), pya.Point(*w2.points[1]) ] 
      # the end of waveguide 2:
      np = len(w2.points)
      w2_segment2 = [ pya.Point(*w2.points[np-2]), pya.Point(*w2.points[np-1]) ] 

      # check 4 possibilities:
      for j in range(0,2):
        if j==0:
          w1_seg=w1_segment1
        else:
          w1_seg=w1_segment2
        for k in range(0,2):
          if k==0:
            w2_seg=w2_segment1
          else:
            w2_seg=w2_segment2
            
          # perform comparison between each of the waveguide ends:
          check = check_segments_collinear_overlapping( w1_seg, w2_seg )
          if check:  # found connected pins:
            # make a new optical net
            net_idx = len(optical_nets)
            optical_nets.append ( Optical_net (net_idx, 0, w1.idx, 0, w2.idx) )
            if j==0:
              optical_waveguides[w1.idx].net1 = net_idx
            else:
              optical_waveguides[w1.idx].net2 = net_idx
            if k==0:
              optical_waveguides[w2.idx].net1 = net_idx
            else:
              optical_waveguides[w2.idx].net2 = net_idx
            print("connected: waveguide-waveguide")


# end def identify_all_nets



def identify_all_nets_fast(optical_pins, optical_waveguides, optical_components):
  # function to identify all the nets from the layout
  # use the data in Optical_pin, Optical_waveguide to find overlaps
  # and save results in Optical_component

  # Make sure that there are exactly 2 pins for each net (not like in electronics!)

  # make a database of pins and waveguide ends
  # sort the pins by x, y.  
  # - find overlapping pins / waveguide ends
  
  # data structure used for all pins.
  class All_pins:
    def __init__(self, x, y, pin_type, ):
      self.detector_net = detector_net
      self.detector_number = detector_number
  all_pins = []  


def find_optical_IO_pins(optical_pins):
  pins_text = ""
  for p in optical_pins:
    if p.pin_type == 2:
      pins_text += " N$%s" % p.net
  return pins_text



def generate_Spice_file(topcell, optical_waveguides, optical_components, optical_pins):
  # list all Optical_component objects from an array
  # input array, optical_components
  # example output:         
  # X_grating_coupler_1 N$7 N$6 grating_coupler library="custom/genericcml" sch_x=-1.42 sch_y=-0.265 sch_r=0 sch_f=false


  # Determine the positions of all the components, in order to determine scaling
  sch_positions = []
  for o in optical_components:
    sch_positions.append ([ o.x, o.y ])
  for o in optical_waveguides:
    x,y = xy_mean_mult(o.points, dbu)
    sch_positions.append ([ x,y ])
  sch_distances = []
  for j in range(len(sch_positions)):
    for k in range(j+1,len(sch_positions)):
      dist = distance_xy ( sch_positions[j], sch_positions[k] )
      sch_distances.append ( dist )

  # find minimum distance between objects, but skip the closest x %, to make the layout more compact
  # e.g., terminators connected to ring resonators are very close.
  # not implemented...

  sch_distances.sort()
  print("Distances between components: %s" % sch_distances)
  
  # remove any 0 distances:
  while 0.0 in sch_distances: sch_distances.remove(0.0)
  
  # scaling based on nearest neighbour:
  Lumerical_schematic_scaling = 0.0006 / min(sch_distances)

  # but if the layout is too big, limit the size
  MAX_size = 0.05
  if max(sch_distances)*Lumerical_schematic_scaling &gt; MAX_size:
    Lumerical_schematic_scaling = MAX_size / max(sch_distances) 
  print ("Scaling for Lumerical INTERCONNECT schematic: %s" % Lumerical_schematic_scaling)

#  Lumerical_schematic_scaling = 5e-2
#  Lumerical_schematic_scaling = 20e-2
#  Lumerical_schematic_scaling = 5e-3

  # convert KLayout GDS rotation/flip to Lumerical INTERCONNECT
  # KLayout defines mirror as an x-axis flip, whereas INTERCONNECT does y-axis flip
  # KLayout defines rotation as counter-clockwise, whereas INTERCONNECT does clockwise
  # input is KLayout Rotation,Flip; output is INTERCONNECT:
  KLayoutInterconnectRotFlip = \
      {(0, False):[0, False], \
       (90, False):[270, False], \
       (180, False):[180, False], \
       (270, False):[90, False], \
       (0, True):[180,True], \
       (90, True):[90, True], \
       (180, True):[0,True], \
       (270, True):[270, False]}

  from time import strftime 
  
  text_main = '* Spice output from KLayout SiEPIC PDK v%s, %s.\n\n' % (SiEPIC_Version, strftime("%Y-%m-%d %H:%M:%S") )
  text_subckt = text_main

#wtext.insertHtml('.subckt %s %s:&lt;br&gt;' % ( topcell.name, find_optical_IO_pins(optical_pins) ))
  opticalIO_pins = find_optical_IO_pins(optical_pins)  

  # find electrical IO pins
  electricalIO_pins = ""
  DCsources = "" # string to create DC sources for each pin
  Vn = 1
  SINGLE_DC_SOURCE = 2
  # (1) attach all electrical pins to the same DC source
  # (2) or to individual DC sources
  # (3) or choose based on number of DC sources, if &gt; 5, use single DC source
  for o in optical_components:
    for p in o.epins:  # electrical pins
      NetName = " N$" + o.component +'_' + str(o.idx) + '_' + p
#      NetName = " C" + str(o.idx) + '_' + p
      electricalIO_pins += NetName
      DCsources += "N" + str(Vn) + NetName + " 0 dcsource amplitude=0 sch_x=%s sch_y=%s\n" % (-2-Vn/10., -2+Vn/8.)
      Vn += 1
  electricalIO_pins_subckt = electricalIO_pins

  if (SINGLE_DC_SOURCE == 1) or ( (SINGLE_DC_SOURCE == 2) &amp; (Vn &gt; 5)):
    electricalIO_pins_subckt = ""
    for o in optical_components:
      for p in o.epins:  # electrical pins
        NetName = " N$"
        electricalIO_pins_subckt += NetName
        DCsources = "N1" + NetName + " 0 dcsource amplitude=0 sch_x=-2 sch_y=0\n"
      
  # create the top subckt:
  text_subckt += '.subckt %s%s%s\n' % (topcell.name, electricalIO_pins, opticalIO_pins)
  text_subckt += '.param MC_uniformity_width=0 \n' # assign MC settings before importing netlist components
  text_subckt += '.param MC_uniformity_thickness=0 \n' 
  text_subckt += '.param MC_resolution_x=100 \n' 
  text_subckt += '.param MC_resolution_y=100 \n' 
  text_subckt += '.param MC_grid=10e-6 \n' 
  text_subckt += '.param MC_non_uniform=99 \n' 

  # Get information about the laser and detectors:
  laser_net, detector_nets, wavelength_start, wavelength_stop, wavelength_points, orthogonal_identifier, ignoreOpticalIOs = \
        get_LumericalINTERCONNECT_analyzers(topcell, optical_pins)
  
  for o in optical_components:
  
    nets_str = ""
    for p in o.epins:  # electrical pins
      nets_str += " N$" + o.component +'_' + str(o.idx) + '_' + p
    for n in o.nets:  # optical nets
      nets_str += " N$" + str(n)

    trans = KLayoutInterconnectRotFlip[(o.rotate, o.flip)]
     
    flip = ' sch_f=true' if trans[1] else ''
    if trans[0] &gt; 0:
      rotate = ' sch_r=%s' % str(trans[0])
    else:
      rotate = ''
#    t = '%s %s %s library="%s" lay_x=%s lay_y=%s sch_x=%s sch_y=%s %s%s'  % \
#         ( "X"+o.component+"_"+str(o.idx), nets_str, o.component, o.library, str (o.x * 1e-6), o.y * 1e-6, o.x, o.y, rotate, flip)
#    t = '  %s %s %s library="%s" %s $X=%s $Y=%s sch_x=%s sch_y=%s %s%s'  % \
    
    # Check to see if this component is an Optical IO type.
    pinIOtype = 0
    for p in o.pins:
      if optical_pins[p].pin_type == 2:
        pinIOtype = 1        
    if ignoreOpticalIOs and pinIOtype:
      # Replace the Grating Coupler or Edge Coupler with a 0-length waveguide.
      component1 = "ebeam_wg_strip_1550"
      params1 = "wg_length=0u wg_width=0.500u"
    else:
      component1 =  o.component 
      params1 = o.params
      
    text_subckt += ' %s %s %s ' % ( component1 +"_"+str(o.idx), nets_str, component1 ) 
    if o.library != None:
      text_subckt += 'library="%s" ' % o.library
    text_subckt += '%s lay_x=%s lay_y=%s sch_x=%s sch_y=%s %s%s\n' % \
       ( params1,
         eng_str(o.x * 1e-6), eng_str(o.y * 1e-6), \
         eng_str(o.x * Lumerical_schematic_scaling), eng_str(o.y * Lumerical_schematic_scaling), \
         rotate, flip)

  # list all Optical_waveguides objects from an array
  # input array, optical_waveguides
  # example output:         
  # X5 9 10 ebeam_wg_strip_1550 library="Design kits/ebeam_v1.0" wg_length=7.86299e-06 wg_width=5.085e-07 sch_x=-1.42 sch_y=-0.265

  for o in optical_waveguides:
    nets_str = "N$%s N$%s" %(o.net1, o.net2)
    x,y = xy_mean_mult(o.points, dbu)
    wg_angle =  ( 360- int(round(angle_segment ( [o.points[0], o.points[len(o.points)-1]] ) / 90) * 90) ) % 360
    
#    t = '%s %s %s library="%s" wg_length=%s wg_width=%s lay_x=%s lay_y=%s sch_x=%5.3f sch_y=%5.3f'  % \
#           ( "Xwg" + str(o.idx), nets_str, o.component, o.library, eng_str(o.length*1e-6), eng_str(o.wg_width*1e-6), \
#             eng_str(x * 1e-6), eng_str(y * 1e-6), x, y)
    t = '  %s %s %s library="%s" wg_length=%s wg_width=%s sch_x=%s sch_y=%s sch_r=%s points="%s"'  % \
           ( "wg" + str(o.idx), nets_str, o.component, o.library, \
             eng_str(o.length*1e-6), eng_str(o.wg_width*1e-6), \
             eng_str(x * Lumerical_schematic_scaling), eng_str(y * Lumerical_schematic_scaling), \
             #str(o.points).replace('[','(').replace(']',')')  )   # format of waveguide section points
             str(wg_angle), \
             str(o.points).replace(', ',',')  )   # change format, delete space    
    text_subckt += '%s\n' %t

  text_subckt += '.ends %s\n\n' % (topcell.name)

  if laser_net &gt; -1:
    text_main += '* Optical Network Analyzer:\n'
    text_main += '.ona input_unit=wavelength input_parameter=start_and_stop\n  + minimum_loss=80\n  + analysis_type=scattering_data\n  + multithreading=user_defined number_of_threads=1\n' 
    text_main += '  + orthogonal_identifier=%s\n' % orthogonal_identifier
    text_main += '  + start=%4.3fe-9\n' % wavelength_start
    text_main += '  + stop=%4.3fe-9\n' % wavelength_stop
    text_main += '  + number_of_points=%s\n' % wavelength_points
    for i in range(0,len(detector_nets)):
      text_main += '  + input(%s)=%s,N$%s\n' % (i+1, topcell.name, detector_nets[i])
    text_main += '  + output=%s,N$%s\n' % (topcell.name, laser_net)

  # main circuit
  text_main += '%s %s %s %s sch_x=-1 sch_y=-1 ' % (topcell.name, electricalIO_pins_subckt, opticalIO_pins, topcell.name)
  if len(DCsources) &gt; 0:
    text_main += 'sch_r=270\n\n'
  else:
    text_main += '\n\n'

  text_main += DCsources
  
  print(text_main)

  return text_subckt, text_main, len(detector_nets)


def generate_short_spice_files(topcell, optical_waveguides, optical_components, optical_pins):
  # create a list of all the waveguides and components
  temp_list = optical_waveguides + optical_components

  #a list to store connected objects
  list_of_obj = []
  
  
  #Defined class which will be used to create linked objects
  class connected_object:
    current_node = None
    parent_node = None
    child_nodes = []
    
    def __init__(self, parent,current, possible_child_nodes):
      self.current_node = current
      self.parent_node = parent
      self.child_nodes = []
      for each in possible_child_nodes:
        #if each is not current node or parent node then test its relationship
        result = []
        if(each != current and each!=parent):  
          result = [list(each_item) for each_item in self.function_connected(current, each)]
          if(len(result)&gt;0):
            self.child_nodes.append(each)
      
      self.update_nodes(self.child_nodes)
          
    # function to check if two components/waveguides are connected
    def function_connected(self,a,b):
      pins_a = self.return_pins(a)
      pins_b = self.return_pins(b)
      lists = [pins_a, pins_b]
      g = set.intersection(*[set(tuple(x) for x in y) for y in lists])
      return g
      
    #extract pins' coordinates of a component
    def return_pins(self,component):
      component_pins = []
      #if it is a waveguide
      if(isinstance(component, Optical_waveguide)== True):
        first_pt = component.points[0]
        last_pt = component.points[-1]
        for each in optical_pins:
          if([each.x,each.y] == first_pt or [each.x, each.y] == last_pt):
            component_pins.append([each.x, each.y])
      
      # if it is not a waveguide
      elif(isinstance(component, Optical_component)== True):
      #gc's the first one is the pin
        for i in component.pins:
          component_pins.append([optical_pins[i].x, optical_pins[i].y])
      return component_pins
    
    #sets parent node
    def set_parent_node(self, parent):
      self.parent_node = parent
      
    #update children nodes in the list
    def update_nodes(self, children):
      for each in children:
        for item in list_of_obj:
          if(each == item.current_node):
            item.set_parent_node(self.current_node)
            break
  
  
  #if there are items in result then they are connected
  for each_item in temp_list:
    current = each_item
    parent = None
  #find if its parent is in the list_of_obj
    for each_obj in list_of_obj:
      if(current in each_obj.child_nodes):
        parent = each_obj
        break
    #add the object to list_of_obj
    list_of_obj.append(connected_object(parent, current, temp_list))
  
  
  #function to find which GCs are connected to a Detector/Laser
  def find_io_pins(topcell, optical_pins):
    send_out = []    
    layout = topcell.layout()
    LayerINTERCONNECTN = layout.layer(LayerINTERCONNECT)
    # Find the laser and detectors in the layout.
    iter1 = topcell.begin_shapes_rec(LayerINTERCONNECTN)
    while not(iter1.at_end()):
      subcell = iter1.cell()             # cell (component) to which this shape belongs
      if iter1.shape().is_box():
        box = iter1.shape().box.transformed(iter1.itrans())
        if iter1.cell().basic_name() == "LumericalINTERCONNECT_Detector":
          send_out.append([box, "DETECTOR"])        
        if iter1.cell().basic_name() == "LumericalINTERCONNECT_Laser":
          send_out.append([box, "LASER"])
      iter1.next()
    return send_out
    
  lumerical_list = find_io_pins(topcell, optical_pins)
  
  
  #Check if there is one laser
  Proceed = 0
  laser_count = len([1 for each in lumerical_list if(each[1]=='LASER')])

  if(laser_count==1):
    Proceed = 1
      
    #extract grating couplers as they are the only ones connected to an input or output:
#    gc_list = [[each,each.pins] for each in optical_components if('_gc_' in each.component)]
#   revised version which includes all couplers (pin_type = 2) including edge couplers.
    gc_list = [[optical_components[each.component_idx], optical_components[each.component_idx].pins] for each in optical_pins if ( each.pin_type == 2) ]
#    print(gc_list[0][0].component])
    
    #make detector or laser string as a parent_node of the extracted gcs which will be used as a reference
    #to identify connected GCs
    
    for items in lumerical_list:
      x_ = []
      y_ = []
      if(items[0].p1.x &lt; items[0].p2.x): 
        x_ = [items[0].p1.x, items[0].p2.x]
      else:
        x_ = [items[0].p2.x, items[0].p1.x]
      
      if(items[0].p1.y &lt; items[0].p2.y):
        y_ = [items[0].p1.y, items[0].p2.y]
      else:
        y_ = [items[0].p2.y, items[0].p1.y]
            
      for each_item in gc_list:
        for pin in each_item[1]:
          if(optical_pins[pin].x &gt; x_[0] and optical_pins[pin].x &lt; x_[1] and optical_pins[pin].y &gt; y_[0] and optical_pins[pin].y &lt; y_[1]):
            gc_ = each_item[0]
            for i in range(len(list_of_obj)):
              if(list_of_obj[i].current_node == gc_):
                list_of_obj[i].set_parent_node(items[1])
                print(gc_)
            break
      
      
    #Make groups based on the connections of nodes
    #make a copy
    grouped_items = []
    copied_nodes = set(list_of_obj)
    
    while copied_nodes:
      #get a random node
      random_node = copied_nodes.pop()
      
      #create a set to store all the connected nodes
      group = set([random_node])
      
      #store the iterable items
      queue = [random_node]
      
      while queue:
        
        #get first element from the list
        qnode = queue.pop(0)
        
        #get child nodes
        children = qnode.child_nodes
        
        new_children = set()
        #form a set of child nodes with their corresponding connected_object objects
        for each in list_of_obj:
          if(each.current_node in children):
            new_children.update([each])
        
        #remove children already opened
        new_children.difference_update(group)
        
        #remove the remaining nodes from the global set
        copied_nodes.difference_update(new_children)
        
        #add them to the group of connected nodes
        group.update(new_children)
        
        #add them to the queue
        queue.extend(new_children)
      
      grouped_items.append(group)
      
    #make a list of groups
    temp_group_list = [list(each) for each in grouped_items]
    
    final_group_list=[]
    #remove the groups with no detectors/lasers and store them in final_group_list
    for each in temp_group_list:
        if(any(x.parent_node == "DETECTOR" or x.parent_node == "LASER" for x in each) == True):
          temp = [i.current_node for i in each]
          final_group_list = final_group_list + temp
    
    
    #get separate lists of fetched optical_waveguides and optical_components
    optical_waveguideF = []
    optical_componentF = []
    
    for each in final_group_list:
      if(isinstance(each,Optical_waveguide)):
        optical_waveguideF.append(each)
      elif(isinstance(each,Optical_component)):
        optical_componentF.append(each)
    
      
    ##COPY PASTES THE FOLLOWING CODE TO TEST WHETHER IT GENERATES SPICE FILE W/ THE 
    ##"generate_Spice_file" FUNCTION  
    
    #Keep only the connected pins
    pins_indexes = [] #indexes of pins to keep
    for each in final_group_list:
      if(isinstance(each,Optical_component)):
        pins_indexes = each.pins + pins_indexes
    #now remove the pins which are not associated with the connected group
    optical_pinsF = []
    for each in optical_pins:
      if(each.idx in pins_indexes):
        optical_pinsF.append(each)
         
    optical_pins = []
    optical_pins = optical_pinsF
    
    
    # Output the Spice netlist:
    return generate_Spice_file(topcell, optical_waveguideF, optical_componentF, optical_pins)

  if(laser_count==0):

    v = pya.MessageBox.warning("Check Laser Question", "There is no Laser defined in the layout.\nOne laser and at least one detector are required to perform a circuit simulation; add them and try again (click ABORT).\nAlternatively, the circuit can be exported as-is but the sources will need to be defined manually within INTERCONNECT (click YES).", pya.MessageBox.Abort + pya.MessageBox.Yes)
    Proceed = 1
    if v == pya.MessageBox.Abort:
      try:
        pass
        raise ValueError("IGNORE THIS ERROR. MANUALLY RAISED")
      except Exception:
        sys.exit(1)
    if v == pya.MessageBox.Yes:
      return generate_Spice_file(topcell, optical_waveguides, optical_components, optical_pins)
    
  if(laser_count&gt;1):
    #show error and teminate
    try:
       pya.MessageBox.warning("Check Laser Error", "There is more than one Laser in the layout.\nPlease make sure that there is only one laser.", pya.MessageBox.Ok)
       raise ValueError("IGNORE THIS ERROR. MANUALLY RAISED")
    except Exception:
      sys.exit(1)

  #we need to raise an error rather than showing a message box warning because it would not stop the code from running and will throw errors in the script we
  #are running this code from
    #pya.MessageBox.warning("Check Laser Error", "There is more than one Laser in the layout.\nPlease make sure that there is only one laser.", pya.MessageBox.Ok)
    



def eng_str(x):
    import math
    # x input in meters
    # output in meters, engineering notation, rounded to 1 nm
    
    EngExp_notation = 1 # 1 = "1.0e-6", 0 = "1.0u"
    x = round(x*1E9)/1E9
    y = abs(x)
    if y == 0:
      return '0'
    else:
      exponent = int(math.floor(math.log10(y)))
      engr_exponent = exponent - exponent%3
      if engr_exponent == -3:
        str_engr_exponent = "m"
        z = y/10**engr_exponent
      elif engr_exponent == -6:
        str_engr_exponent = "u"
        z = y/10**engr_exponent
      elif engr_exponent == -9:
        str_engr_exponent = "n"
        z = y/10**engr_exponent
      else:
        str_engr_exponent = ""
        z = y/10**engr_exponent
      sign = '-' if x &lt; 0 else ''
      if EngExp_notation:
        return sign+str(z)+'E'+str(engr_exponent)
#      return sign+ '%3.3f' % z +str(str_engr_exponent)
      else:
        return sign+ str(z) +str(str_engr_exponent)


def netlist_extraction(topcell):
  # Collection of functions to extract the circuit netlist from the physical layout
  
  import time

  # Search the layout for the components and waveguides:
  print("")
  print("* calling find_all_components() - DevRec:")
  find_all_components(topcell, LayerDevRecN, LayerPinRecN, LayerFbrTgtN)
  clock_find_all_components = time.clock()

  print("")
  print("* calling find_all_waveguides():")
  find_all_waveguides(topcell, LayerSiN)
  clock_find_all_waveguides = time.clock()

  print("")
  print("* print_Optical_all, after find_all_{components, waveguides}:")
  print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets)

  # Search the arrays to identify all the nets:
  print("")
  print("* calling identify_all_nets():")
  identify_all_nets(optical_pins, optical_waveguides, optical_components)
  clock_identify_all_nets = time.clock()

  print("")
  print("print_Optical_all, after identify_all_nets:")
  print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets)

  return optical_waveguides, optical_components, \
  clock_find_all_components, clock_find_all_waveguides, clock_identify_all_nets


  
def flag_waveguide_error(dpoints, text, optical_waveguide, topcell):
  # global variable "layout_errors" of class "Layout_error" used for storing all the errors.
  a1 = []
  for p in dpoints:
    a1.append (pya.Point(int(p[0]), int(p[1])))
  path = pya.Path(a1, optical_waveguide.wg_width*4/dbu)
  x,y = xy_mean_mult(dpoints, dbu)
  layout_errors.append(Layout_error(text, x, y) )
  print(text)
  if 'wtext' in globals():
#    topcell.shapes(LayerErrorN).insert(path)
    wtext.insertHtml('%s&lt;br&gt;' %text)


def check_waveguides(rdb, optical_waveguides, topcell, error_layer):
  # check waveguides for basic errors.
  num_errors=0

  rdb_cell = next(rdb.each_cell())

  rdb_cat_id_wg = rdb.create_category("Waveguide errors")
  
  rdb_cat_id_wg_path = rdb.create_category(rdb_cat_id_wg, "Path")
  rdb_cat_id_wg_path.description = "Waveguide path: Only 2 points allowed in a path. Convert to a waveguide (ROUND_PATH) if necessary."

  rdb_cat_id_wg_radius = rdb.create_category(rdb_cat_id_wg, "Radius")
  rdb_cat_id_wg_radius.description = "Not enough space to accommodate the desired bend radius for the waveguide."

  rdb_cat_id_wg_bendpts = rdb.create_category(rdb_cat_id_wg, "Bend points")
  rdb_cat_id_wg_bendpts.description = "Waveguide bend should have more points per circle."

  rdb_cat_id_wg_manhattan = rdb.create_category(rdb_cat_id_wg, "Manhattan")
  rdb_cat_id_wg_manhattan.description =  "The first and last waveguide segment need to be Manhattan (vertical or horizontal) so that they can connect to device pins."


  for o in optical_waveguides:

    # Check for paths with &gt; 2 vertices
    if (o.wg_type == 0 and o.num_points &gt; 2):
      text = "  *** Layout error.  Waveguide path (%s, %s): Only 2 points allowed in a path. Convert to a waveguide (ROUND_PATH) if necessary. " \
            % ( o.points[0][0]*dbu, o.points[0][1]*dbu) 
      dpoints = o.points
      num_errors += 1
      flag_waveguide_error(dpoints, text, o, topcell)
      rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_path.rdb_id())
      rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )

    # find the minimum segment to make sure that the bends have large enough radius
    if (o.wg_type == 1):
      # first segment:
      segment = distance_xy ( o.points[0], o.points[1] ) 
      if segment &lt; o.radius:
        text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s) for waveguide end." % (segment, o.radius)
        dpoints=[ o.points[0], o.points[1] ] 
        num_errors += 1
        flag_waveguide_error(dpoints, text, o, topcell)
        rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_radius.rdb_id())
        rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )
      # last segment:
      segment = distance_xy ( o.points[len(o.points)-2], o.points[len(o.points)-1] ) 
      if segment &lt; o.radius:
        text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s) for waveguide end." % (segment, o.radius)
        dpoints=[ o.points[len(o.points)-2], o.points[len(o.points)-1] ]
        num_errors += 1
        flag_waveguide_error(dpoints, text, o, topcell)
        rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_radius.rdb_id())
        rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )
      # go through each of the middle segments:
      for j in range(1, len(o.points)-2):
        segment = distance_xy ( o.points[j], o.points[j+1] ) 
        if segment &lt; 2*o.radius and segment != 0:
          text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s) for a mid-segment." % (segment, o.radius)
          dpoints=[ o.points[j], o.points[j+1] ] 
          num_errors += 1
          flag_waveguide_error(dpoints, text, o, topcell)
          rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_radius.rdb_id())
          rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )

      # Check for waveguides with too few bend points
      recommended_points = points_per_circle(o.radius)
      if o.bend_pts &lt; 0.75 * recommended_points:
        text =  "  *** Layout warning.  Waveguide bends should have at least %s points per circle for a %s micron radius." \
                     % (int(recommended_points), o.radius)
        dpoints=o.points
        num_errors += 1
        flag_waveguide_error(dpoints, text, o, topcell)
        rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_bendpts.rdb_id())
        rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )
      # Check if waveguide end segments are Manhattan; this ensures they can connect to a pin
      # first segment
      if ( o.points[0][0] != o.points[1][0] and o.points[0][1] != o.points[1][1] ):
        num_errors += 1
        text =  "  *** Layout warning.  The first and last waveguide segment need to be Manhattan (vertical or horizontal) so that they can connect to device pins."
        dpoints=[ o.points[0], o.points[1] ] 
        flag_waveguide_error(dpoints, text, o, topcell)
        rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_manhattan.rdb_id())
        rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )
      # last segment
      last = len(o.points)-1
      if ( o.points[last][0] != o.points[last-1][0] and o.points[last][1] != o.points[last-1][1] ):
        num_errors += 1
        text =  "  *** Layout warning.  The first and last waveguide segment need to be Manhattan (vertical or horizontal) so that they can connect to device pins."
        dpoints=[ o.points[last-1], o.points[last] ]
        flag_waveguide_error(dpoints, text, o, topcell)
        rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_manhattan.rdb_id())
        rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )

  return num_errors


def check_components(rdb, cell, LayerDevRecN):
  # function to go through all the cells
  # check that the cell has at most ONE DevRec shape.  
  return False
 
 

def flag_component_error(box, text, x, y):
  # global variable "layout_errors" of class "Layout_error" used for storing all the errors.
  layout_errors.append(Layout_error(text, x, y) )
  print(text)
  if 'wtext' in globals():
#    topcell.shapes(LayerErrorN).insert(box)
    wtext.insertHtml('%s&lt;br&gt;' %text)


def check_connectivity(rdb, optical_components, topcell, LayerErrorN):
  # Make sure that all pins/waveguides are connected, i.e., dangling pins/waveguides.
  # Flag disconnected pins
  # Flag disconnected waveguides
  # Make sure that waveguides / pins are connected in the correct direction (identify_nets only finds collinear pins/waveguides) 

  num_errors=0

  rdb_cell = next(rdb.each_cell())

  rdb_cat_id = rdb.create_category("Connectivity errors")

  rdb_cat_id_discwg = rdb.create_category(rdb_cat_id, "Disconnected waveguide")
  rdb_cat_id_discwg.description = "Disconnected waveguides"

  rdb_cat_id_discpin = rdb.create_category(rdb_cat_id, "Disconnected pin")
  rdb_cat_id_discpin.description = "Disconnected pin"

  if 0:
   for k in range(0,len(optical_components)):
    if optical_components[k].npins != len(optical_components[k].nets):
      text = "  *** Connectivity error.  Mismatch between the number of pins (%s) on the component (%s, %s) at (%s, %s), and the number of nets (%s)." \
            % ( optical_components[k].npins, optical_components[k].component, optical_components[k].idx, \
                optical_components[k].x, optical_components[k].y, len(optical_components[k].nets) )
      bbox = layout.cell(optical_components[k].instance).bbox()
      box = bbox.transformed(pya.Trans(optical_components[k].rotate, optical_components[k].flip, \
                optical_components[k].x/dbu,optical_components[k].y/dbu))
#      flag_component_error(box, text, optical_components[k].x, optical_components[k].y)

      # go through all the pins in the component, and check if they aren't assigned to a net
      for m in range(0,optical_components[k].npins):
        pin = optical_pins[optical_components[k].pins[m]]
        if pin.net == 0 and pin.pin_type == 1:  # disconnected pin on a pin_type = 1 (component)
          text = "  *** Found disconnected pin #%s at (%s, %s)." % (pin.idx, pin.x*dbu, pin.y*dbu)
          box = pya.Box(pin.x-3000, pin.y-3000, pin.x+3000, pin.y+3000)
#          flag_component_error(box, text, pin.x*dbu, pin.y*dbu)

  for pin in optical_pins:
    if pin.net == -1 and pin.pin_type != 2:  # disconnected pin not on a pin_type = 2 (optical IO)
      text = "  *** Found disconnected pin #%s, type %s, at (%s, %s), component #%s {%s}" \
          % (pin.idx, pin.pin_type, pin.x*dbu, pin.y*dbu, \
             pin.component_idx, optical_components[pin.component_idx].component)
      box = pya.Box(pin.x-3000, pin.y-3000, pin.x+3000, pin.y+3000)
      num_errors += 1
      flag_component_error(box, text, pin.x*dbu, pin.y*dbu)
      rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_discpin.rdb_id())
      rdb_item.add_value(pya.RdbItemValue( pya.DBox(pin.x*dbu-0.3, pin.y*dbu-0.3, pin.x*dbu+0.3, pin.y*dbu+0.3) ) )

  for w1 in optical_waveguides:
    print(w1.points)
    # examine the beginning of the waveguide:
    if w1.net1 == -1:
      text = "  *** Found disconnected waveguide at (%s, %s), net1" \
          % (w1.points[0][0]*dbu, w1.points[0][1]*dbu)
      dpoints = [w1.points[0], w1.points[1]]
      num_errors += 1
      flag_waveguide_error( dpoints, text, optical_waveguides[w1.idx], topcell)
      rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_discwg.rdb_id())
      rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),w1.wg_width) ) )
    # examine the end of the waveguide:
    if w1.net2 == -1:
      text = "  *** Found disconnected waveguide at (%s, %s), net2" \
          % (w1.points[len(w1.points)-1][0]*dbu, w1.points[len(w1.points)-1][1]*dbu)
      dpoints = [w1.points[len(w1.points)-1], w1.points[len(w1.points)-2]]
      print(dpoints)
      num_errors += 1
      flag_waveguide_error(dpoints, \
               text, optical_waveguides[w1.idx], topcell)
      rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_discwg.rdb_id())
      rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),w1.wg_width) ) )

  return num_errors
    


def list_optical_components(optical_components):
  # list all Optical_component objects from an array
  # input array, optical_components
  # example output:         
  # X_grating_coupler_1 N$7 N$6 grating_coupler library="custom/genericcml" sch_x=-1.42 sch_y=-0.265 sch_r=0 sch_f=false

  for o in optical_components:
    nets_str = ""
    for n in o.nets:
      nets_str += " N$" + str(n)
    flip = ' sch_f=true' if o.flip else ''
    if o.rotate &gt; 0:
      rotate = ' sch_r=%s' % str(o.rotate)
    else:
      rotate = ''
#    t = '%s %s %s library="%s" lay_x=%s lay_y=%s sch_x=%s sch_y=%s %s%s'  % \
#         ( "X"+o.component+"_"+str(o.idx), nets_str, o.component, o.library, str (o.x * 1e-6), o.y * 1e-6, o.x, o.y, rotate, flip)
    t = '  %s %s %s library="%s" sch_x=%s sch_y=%s %s%s'  % \
         ( "X"+o.component+"_"+str(o.idx), nets_str, o.component, o.library, eng_str(o.x * 5e-2), eng_str(o.y * 5e-2), rotate, flip)
    print(t)
    wtext.insertHtml('%s&lt;br&gt;' %t)

def list_optical_waveguides(list_optical_waveguides):
  # list all Optical_waveguides objects from an array
  # input array, optical_waveguides
  # example output:         
  # X5 9 10 ebeam_wg_strip_1550 library="Design kits/ebeam_v1.0" wg_length=7.86299e-06 wg_width=5.085e-07 sch_x=-1.42 sch_y=-0.265

  for o in list_optical_waveguides:
    nets_str = "N$%s N$%s" %(o.net1, o.net2)
    x,y = xy_mean_mult(o.points, dbu)
#    t = '%s %s %s library="%s" wg_length=%s wg_width=%s lay_x=%s lay_y=%s sch_x=%5.3f sch_y=%5.3f'  % \
#           ( "Xwg" + str(o.idx), nets_str, o.component, o.library, eng_str(o.length*1e-6), eng_str(o.wg_width*1e-6), \
#             eng_str(x * 1e-6), eng_str(y * 1e-6), x, y)
    t = '  %s %s %s library="%s" wg_length=%s wg_width=%s sch_x=%s sch_y=%s'  % \
           ( "Xwg" + str(o.idx), nets_str, o.component, o.library, \
             eng_str(o.length*1e-6), eng_str(o.wg_width*1e-6), eng_str(x * 5e-2), eng_str(y * 5e-2))
    print(t)
    wtext.insertHtml('%s&lt;br&gt;' %t)




def terminate_all_disconnected_pins(optical_pins, optical_waveguides, optical_components):
  """
  Find all disconnected pins, and add a disconnected component for circuit simulations
  to properly account for reflections.
  Function based on check_connectivity().
  
  steps:
   - Find all disconnected pins &amp; waveguides
   - to do: attempt to recognize if it is connected to a TE or TM circuit
   - Add "disconnected" component to all disconnected pins &amp; waveguides
  """

  print ("running - terminate_all_disconnected_pins():")

  # attach a TE disconnected component to disconnected pins.
  component = "ebeam_disconnected_te1550"  # disconnected pin model name
  library = "Design kits/ebeam_v1.2" # compact model library
  
  for pin in optical_pins:
    if pin.net == -1 and pin.pin_type != 2:  # disconnected pin not on a pin_type = 2 (optical IO)
      x, y = pin.x*dbu, pin.y*dbu
      text = "  *** Found disconnected pin #%s, type %s, at (%s, %s), component #%s {%s}" \
          % (pin.idx, pin.pin_type, x, y, \
             pin.component_idx, optical_components[pin.component_idx].component)
      print(text)

      # Add "disconnected" component:
      component_idx = len(optical_components)
      optical_components.append ( Optical_component (component_idx, \
                  component, component, x, y, 0, 0, library, "") )
      # Make an optical net
      net_idx = len(optical_nets)
      optical_nets.append ( Optical_net (net_idx, 1, pin.component_idx, \
                            1, optical_components[component_idx].idx) )
      # update pin
      pin.net = net_idx
      # update the two components.  find where the pin is in the first component.
      optical_components[pin.component_idx].nets\
          [optical_components[pin.component_idx].pins.index(pin.idx)] \
          = net_idx
      optical_components[component_idx].nets.append ( net_idx )
        
  for w1 in optical_waveguides:
    # examine the beginning of the waveguide:
    if w1.net1 == -1:
      x, y = w1.points[0][0]*dbu, w1.points[0][1]*dbu
      text = "  *** Found disconnected waveguide at (%s, %s), net1" \
          % (x, y)
      print(text)
      
      # Add "disconnected" component:
      component_idx = len(optical_components)
      optical_components.append ( Optical_component (component_idx, \
                  component, component, x, y, 0, 0, library, "") )
      # Make an optical net
      net_idx = len(optical_nets)
      optical_nets.append ( Optical_net (net_idx, 0, w1.idx, \
                            1, optical_components[component_idx].idx) )
      # update pin
      pin.net = net_idx
      # update the new component.  
      optical_components[component_idx].nets.append ( net_idx )
      # update the waveguide
      w1.net1 = net_idx

    # examine the end of the waveguide:
    if w1.net2 == -1:
      x, y = w1.points[len(w1.points)-1][0]*dbu, w1.points[len(w1.points)-1][1]*dbu
      text = "  *** Found disconnected waveguide at (%s, %s), net2" \
          % (x,y)
      print(text)

      # Add "disconnected" component:
      component_idx = len(optical_components)
      optical_components.append ( Optical_component (component_idx, \
                  component, component, x, y, 0, 0, library, "") )
      # Make an optical net
      net_idx = len(optical_nets)
      optical_nets.append ( Optical_net (net_idx, 0, w1.idx, \
                            1, optical_components[component_idx].idx) )
      # update pin
      pin.net = net_idx
      # update the new component.  
      optical_components[component_idx].nets.append ( net_idx )
      # update the waveguide
      w1.net2 = net_idx

  return optical_waveguides, optical_components



def waveguide_set_target_length():
  # Function to move the edges of a waveguide to obtain a target length
  # - Dialog prompts user for a target length, and to click on an edge to select shape and edge to move
  # - Newton search: calculate length (area method) then move edge; technique is general for any waveguide curve function
  pass
    
def check_pdk_directory():
  import os
  #file list
  file_list = []
  #get username
  username = os.path.dirname(os.path.realpath(__file__)).split('\\')[2]
  #get path to global directory
  path = r"C:\Users\%s\AppData\Roaming\KLayout (64bit)\pymacros"%(username)
  for dirName, subdirList, fileList in os.walk(path):
    for fname in fileList:
        file_list.append('%s' % fname)
  for each in file_list:
    #check if SiEPIC functions file is in the list
    if('SiEPIC_EBeam_functions' in each):
      #show warning message
      pya.MessageBox.warning("Incorrect File Directory", "PDK installed in the Global folder.\nIt should be installed in the KLayout Configuration folder: \n"+ r"C:\Users\%s\KLayout\pymacros"%(username), pya.MessageBox.Ok)

def transform_to_offset(path, offset):
  from math import pi, cos, sin, acos, sqrt
  def angle_trunc(a):
    while a &lt; 0.0:
      a += pi * 2
    return a

  def angle(vec):
    return angle_trunc(atan2(vec[1],vec[0]))

  trans_path = [row[:] for row in path]
  
  for i in range(0, len(path)):
    if i == 0:
      u = [-(path[i+1][0]-path[i][0]), -(path[i+1][1]-path[i][1])]
      v = [path[i+1][0]-path[i][0], path[i+1][1]-path[i][1]]
    elif i == (len(path) - 1):
      u = [path[i-1][0]-path[i][0], path[i-1][1]-path[i][1]]
      v = [-(path[i-1][0]-path[i][0]), -(path[i-1][1]-path[i][1])]
    else:
      u = [path[i-1][0]-path[i][0], path[i-1][1]-path[i][1]]
      v = [path[i+1][0]-path[i][0], path[i+1][1]-path[i][1]]

    if offset &lt; 0:
      o1 = [abs(offset)*cos(angle(u)-pi/2), abs(offset)*sin(angle(u)-pi/2)]
      o2 = [abs(offset)*cos(angle(v)+pi/2), abs(offset)*sin(angle(v)+pi/2)]
    else:
      o1 = [abs(offset)*cos(angle(u)+pi/2), abs(offset)*sin(angle(u)+pi/2)]
      o2 = [abs(offset)*cos(angle(v)-pi/2), abs(offset)*sin(angle(v)-pi/2)]
    
    p1 = [u[0]+o1[0], u[1]+o1[1]]
    p2 = [o1[0], o1[1]]
    p3 = [v[0]+o2[0], v[1]+o2[1]]
    p4 = [o2[0], o2[1]]
    
    d = (p1[0]-p2[0])*(p3[1]-p4[1])-(p1[1]-p2[1])*(p3[0]-p4[0])
    if round(d,10) == 0:
      trans_path[i][0] = trans_path[i][0] + p2[0]
      trans_path[i][1] = trans_path[i][1] + p2[1]
    else:
      trans_path[i][0] = trans_path[i][0] + ((p1[0]*p2[1]-p1[1]*p2[0])*(p3[0]-p4[0])-(p1[0]-p2[0])*(p3[0]*p4[1]-p3[1]*p4[0]))/d
      trans_path[i][1] = trans_path[i][1] + ((p1[0]*p2[1]-p1[1]*p2[0])*(p3[1]-p4[1])-(p1[1]-p2[1])*(p3[0]*p4[1]-p3[1]*p4[0]))/d
    
  return trans_path</text>
</klayout-macro>
